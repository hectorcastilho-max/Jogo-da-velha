<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Jogo da Velha — Jogar contra a Máquina</title>
<style>
  :root{
    --bg:#0f1724;
    --card:#0b1220;
    --accent1:#7c3aed;
    --accent2:#06b6d4;
    --text:#e6eef8;
    --muted:#9fb0c8;
    --board-size:360px; /* base size; visually scaled */
  }
  *{box-sizing:border-box;font-family:Inter,ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial;}
  html,body{height:100%;margin:0;background:radial-gradient(1200px 600px at 10% 10%, rgba(124,58,237,0.08), transparent 8%),
               radial-gradient(900px 500px at 90% 90%, rgba(6,182,212,0.06), transparent 12%), var(--bg);
            color:var(--text);overflow:hidden;}
  /* floating decorative shapes */
  .decor {
    position:fixed;left:0;top:0;right:0;bottom:0;pointer-events:none;overflow:hidden;
  }
  .float {
    position:absolute;border-radius:50%;opacity:0.12;
    animation: floaty linear infinite;
    filter: blur(8px);
  }
  .float.a{width:260px;height:260px;background:linear-gradient(45deg,#7c3aed,#06b6d4);left:-10%;top:5%;animation-duration:18s;}
  .float.b{width:200px;height:200px;background:linear-gradient(45deg,#06b6d4,#7c3aed);right:-12%;bottom:5%;animation-duration:22s;}
  @keyframes floaty{0%{transform:translateY(0) translateX(0)}50%{transform:translateY(-40px) translateX(20px)}100%{transform:translateY(0) translateX(0)}}

  .container{
    min-height:100vh;display:flex;align-items:center;justify-content:center;padding:32px;
  }
  .card{
    width:calc(var(--board-size) + 240px);
    max-width:95vw;
    background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.06));
    border-radius:16px;padding:20px;box-shadow:0 8px 30px rgba(2,6,23,0.7);backdrop-filter: blur(6px);
    display:grid;grid-template-columns: 1fr 1fr; gap:18px;align-items:start;
  }

  /* Left column: controls + messages */
  .controls{
    padding:12px;border-radius:12px;background:linear-gradient(180deg, rgba(124,58,237,0.04), rgba(6,182,212,0.02));
    min-height: calc(var(--board-size) - 40px);
    display:flex;flex-direction:column;gap:12px;
  }
  h1{margin:0;font-size:20px;letter-spacing:0.2px}
  .subtitle{color:var(--muted);font-size:13px;margin-top:6px}

  .options {
    display:flex;flex-direction:column;gap:10px;margin-top:8px;
  }
  .btn-row{display:flex;gap:8px;flex-wrap:wrap}
  .option-btn{
    padding:10px 14px;border-radius:10px;border:2px solid transparent;background:rgba(255,255,255,0.02);
    color:var(--text);cursor:pointer;font-weight:600;
    transition:all .18s;
  }
  .option-btn:hover{transform:translateY(-3px)}
  .option-btn.active{border-color:rgba(255,255,255,0.06);box-shadow:0 6px 18px rgba(12,18,30,0.4);}

  .start-btn{
    margin-top:8px;padding:12px;border-radius:12px;border:none;background:linear-gradient(90deg,var(--accent1),var(--accent2));
    color:white;font-weight:700;cursor:pointer;font-size:15px;
    box-shadow:0 10px 30px rgba(6,182,212,0.06);
  }

  .meta {font-size:13px;color:var(--muted);margin-top:auto}
  .controls .small-btn{background:transparent;border:1px solid rgba(255,255,255,0.04);padding:8px;border-radius:8px;color:var(--muted);cursor:pointer}

  /* Board column */
  .board-wrap{display:flex;flex-direction:column;align-items:center;justify-content:flex-start;gap:12px;padding:14px;}
  .board {
    width:var(--board-size);height:var(--board-size);
    transform:scale(1.25); /* 25% maior */
    max-width:70vw;max-height:70vw;
    display:grid;grid-template-columns:repeat(3,1fr);grid-template-rows:repeat(3,1fr);gap:8px;
    background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    padding:8px;border-radius:14px;
    box-shadow: 0 10px 30px rgba(2,6,23,0.6), inset 0 1px 0 rgba(255,255,255,0.02);
  }
  .cell{
    background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(0,0,0,0.06));
    border-radius:10px;display:flex;align-items:center;justify-content:center;font-size:48px;font-weight:800;color:var(--text);
    cursor:pointer;user-select:none;transition:transform .12s, box-shadow .12s;
    box-shadow: 0 6px 18px rgba(2,6,23,0.4);
  }
  .cell:hover{transform:translateY(-6px) scale(1.02)}
  .cell.disabled{cursor:default;opacity:0.85}
  .status{font-size:15px;color:var(--text);font-weight:700}
  .substatus{font-size:13px;color:var(--muted)}

  .controls-row{display:flex;gap:8px;margin-top:6px}
  .top-actions{display:flex;gap:8px;align-items:center}

  /* confetti pieces */
  .confetti-piece{
    position:fixed;z-index:9999;pointer-events:none;will-change:transform,opacity;
    width:10px;height:14px;border-radius:2px;opacity:0.95;
    transform-origin:center;
    animation: confetti-fall linear forwards;
  }
  @keyframes confetti-fall{
    0%{transform:translateY(-10vh) rotate(0deg);opacity:1}
    100%{transform:translateY(110vh) rotate(720deg);opacity:0}
  }

  /* small footer note */
  footer{grid-column:1/-1;text-align:center;color:var(--muted);font-size:12px;padding-top:8px;}

  /* responsive: stack columns on small screens */
  @media (max-width:900px){
    .card{grid-template-columns:1fr; width: 92vw;}
    .board{transform:scale(1.05)}
  }

  /* winner highlight line */
  .line {
    position:absolute;pointer-events:none;background:linear-gradient(90deg, rgba(255,255,255,0.12), rgba(255,255,255,0.06));
    height:6px;border-radius:6px;z-index:50;transform-origin:center;transition:opacity .2s;
  }

  /* subtle cell place animation */
  .placed{animation:pop .14s ease;}
  @keyframes pop{0%{transform:scale(.6)}100%{transform:scale(1)}}
</style>
</head>
<body>
<div class="decor">
  <div class="float a"></div>
  <div class="float b"></div>
</div>

<div class="container">
  <div class="card" role="application" aria-label="Jogo da Velha">
    <div class="controls">
      <div>
        <h1>Jogo da Velha — vs Máquina</h1>
        <div class="subtitle">Escolha dificuldade e o seu símbolo. A música começa após escolher.</div>
      </div>

      <div class="options">
        <div><strong>Dificuldade</strong></div>
        <div class="btn-row" id="diffRow">
          <button class="option-btn active" data-diff="easy">Fácil</button>
          <button class="option-btn" data-diff="medium">Médio</button>
          <button class="option-btn" data-diff="hard">Difícil</button>
        </div>

        <div style="margin-top:8px"><strong>Seu Símbolo</strong></div>
        <div class="btn-row" id="symRow">
          <button class="option-btn active" data-sym="X">X</button>
          <button class="option-btn" data-sym="O">O</button>
        </div>

        <div style="margin-top:12px">
          <button class="start-btn" id="startBtn">Começar Jogo</button>
        </div>

        <div class="controls-row" style="margin-top:6px">
          <button class="controls small-btn" id="restartBtn" title="Reiniciar jogo">Reiniciar</button>
          <button class="controls small-btn" id="resetOptions" title="Voltar para as opções">Voltar às opções</button>
        </div>
      </div>

      <div style="margin-top:10px">
        <div class="status" id="statusText">Pronto para jogar</div>
        <div class="substatus" id="subStatus">Escolha suas preferências e clique em "Começar Jogo".</div>
      </div>

      <div class="meta">Dificuldades: Fácil (aleatório) • Médio (tenta ganhar/bloquear) • Difícil (Minimax).</div>
      <footer>Feito com ❤ — Divirta-se!</footer>
    </div>

    <div class="board-wrap">
      <div style="position:relative;">
        <div class="board" id="board" aria-label="Tabuleiro do jogo">
          <!-- 9 cells -->
          <div class="cell" data-index="0" role="button" aria-pressed="false"></div>
          <div class="cell" data-index="1" role="button" aria-pressed="false"></div>
          <div class="cell" data-index="2" role="button" aria-pressed="false"></div>
          <div class="cell" data-index="3" role="button" aria-pressed="false"></div>
          <div class="cell" data-index="4" role="button" aria-pressed="false"></div>
          <div class="cell" data-index="5" role="button" aria-pressed="false"></div>
          <div class="cell" data-index="6" role="button" aria-pressed="false"></div>
          <div class="cell" data-index="7" role="button" aria-pressed="false"></div>
          <div class="cell" data-index="8" role="button" aria-pressed="false"></div>
        </div>
        <div id="line" class="line" style="opacity:0;"></div>
      </div>

      <div style="width:100%;display:flex;flex-direction:column;align-items:center;gap:6px;">
        <div class="top-actions" style="width:100%;justify-content:space-between;">
          <div>
            <div class="substatus" id="turnLabel">Jogador: —</div>
            <div class="substatus" id="scoreLabel">Você 0 • Máquina 0 • Empates 0</div>
          </div>
          <div style="display:flex;gap:8px;">
            <button class="option-btn" id="undoBtn" disabled>Desfazer (não implementado)</button>
            <button class="option-btn" id="hintBtn">Dica</button>
          </div>
        </div>

        <div style="font-size:13px;color:var(--muted);text-align:center;padding:6px;">
          Toque/click numa casa para jogar. Caso você escolha "O", a máquina começa (X inicia sempre).
        </div>
      </div>
    </div>

  </div>
</div>

<!-- audio: música instrumental (exemplo público) -->
<audio id="bgAudio" loop crossorigin="anonymous">
  <source src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3" type="audio/mpeg">
  Seu navegador não suporta áudio.
</audio>

<script>
/* =========================
   Jogo da Velha — lógica e UI
   ========================= */

const startBtn = document.getElementById('startBtn');
const diffRow = document.getElementById('diffRow');
const symRow = document.getElementById('symRow');
const boardEl = document.getElementById('board');
const cells = Array.from(document.querySelectorAll('.cell'));
const statusText = document.getElementById('statusText');
const subStatus = document.getElementById('subStatus');
const turnLabel = document.getElementById('turnLabel');
const scoreLabel = document.getElementById('scoreLabel');
const resetOptions = document.getElementById('resetOptions');
const restartBtn = document.getElementById('restartBtn');
const hintBtn = document.getElementById('hintBtn');
const bgAudio = document.getElementById('bgAudio');
const lineEl = document.getElementById('line');

let difficulty = 'easy';
let playerSym = 'X';
let aiSym = 'O';
let board = Array(9).fill(null);
let currentTurn = 'X'; // X always starts
let running = false;
let scores = {player:0, ai:0, ties:0};
let lastMoveIdx = null;

/* Escolha de opções UI */
diffRow.addEventListener('click', (e)=>{
  const btn = e.target.closest('button');
  if(!btn) return;
  diffRow.querySelectorAll('button').forEach(b=>b.classList.remove('active'));
  btn.classList.add('active');
  difficulty = btn.dataset.diff;
});
symRow.addEventListener('click', (e)=>{
  const btn = e.target.closest('button');
  if(!btn) return;
  symRow.querySelectorAll('button').forEach(b=>b.classList.remove('active'));
  btn.classList.add('active');
  playerSym = btn.dataset.sym;
  aiSym = playerSym === 'X' ? 'O' : 'X';
});

/* Start */
startBtn.addEventListener('click', ()=>{
  // start music after user gesture
  try{ bgAudio.currentTime = 0; bgAudio.play().catch(()=>{}); } catch(e){}
  startGame();
});

/* Reset to options (keeps scores) */
resetOptions.addEventListener('click', ()=>{
  running = false;
  board = Array(9).fill(null);
  cells.forEach(c=>{c.textContent='';c.classList.remove('disabled','placed');c.setAttribute('aria-pressed','false')});
  statusText.textContent = 'Pronto para jogar';
  subStatus.textContent = 'Escolha as opções e clique em "Começar Jogo".';
  diffRow.querySelectorAll('button').forEach(b=>b.disabled=false);
  symRow.querySelectorAll('button').forEach(b=>b.disabled=false);
  startBtn.disabled = false;
  lineEl.style.opacity = 0;
});

/* Restart current match (keeps selected options and scores) */
restartBtn.addEventListener('click', ()=>{
  resetBoard();
  if(running && currentTurn === aiSym) {
    // se a máquina começa, joga
    setTimeout(aiPlay, 450);
  }
});

/* Hint button: show recommended move (simple) */
hintBtn.addEventListener('click', ()=>{
  if(!running) return;
  const move = getBestMoveSimple();
  if(move!=null){
    // highlight cell briefly
    const cel = cells[move];
    cel.style.boxShadow = '0 18px 40px rgba(124,58,237,0.18)';
    setTimeout(()=>cel.style.boxShadow = '0 6px 18px rgba(2,6,23,0.4)',900);
  }
});

/* Cells click */
cells.forEach(cell=>{
  cell.addEventListener('click', ()=>{
    if(!running) return;
    const idx = Number(cell.dataset.index);
    // only allow human moves on player's symbol turn
    if(board[idx] !== null) return;
    if(currentTurn !== playerSym) return;
    makeMove(idx, playerSym);
  });
});

/* Start the game (apply options) */
function startGame(){
  diffRow.querySelectorAll('button').forEach(b=>b.disabled=true);
  symRow.querySelectorAll('button').forEach(b=>b.disabled=true);
  startBtn.disabled = true;
  running = true;
  board = Array(9).fill(null);
  currentTurn = 'X'; // X starts
  aiSym = (playerSym === 'X') ? 'O' : 'X';
  updateStatus();
  cells.forEach(c=>{c.textContent='';c.classList.remove('disabled'); c.classList.remove('placed'); c.setAttribute('aria-pressed','false')});
  lineEl.style.opacity = 0;
  // if player chose O, machine (X) starts
  if(playerSym === 'O'){
    setTimeout(aiPlay, 450);
  }
}

/* Reset board only */
function resetBoard(){
  board = Array(9).fill(null);
  currentTurn = 'X';
  running = true;
  cells.forEach(c=>{c.textContent='';c.classList.remove('disabled');c.classList.remove('placed');c.setAttribute('aria-pressed','false')});
  lineEl.style.opacity = 0;
  updateStatus();
}

/* Make a move (idx, symbol) */
function makeMove(idx, symbol){
  if(board[idx] !== null) return;
  board[idx] = symbol;
  const cel = cells[idx];
  cel.textContent = symbol;
  cel.classList.add('placed');
  cel.setAttribute('aria-pressed','true');
  lastMoveIdx = idx;
  // small sound/visual could be added
  // check winner
  const winnerInfo = checkWinner(board);
  if(winnerInfo){
    // winner or tie
    running = false;
    if(winnerInfo.winner){
      announceWin(winnerInfo);
    } else {
      announceTie();
    }
    return;
  }
  // switch turn
  currentTurn = (symbol === 'X') ? 'O' : 'X';
  updateStatus();
  // if next is AI, schedule AI play
  if(running && currentTurn === aiSym){
    setTimeout(aiPlay, 450);
  }
}

/* AI play depending on difficulty */
function aiPlay(){
  if(!running) return;
  let idx;
  if(difficulty === 'easy'){
    idx = getRandomMove();
  } else if(difficulty === 'medium'){
    idx = getMediumMove();
  } else {
    idx = getBestMoveMinimax(board.slice(), aiSym).idx;
  }
  // fallback
  if(idx == null) idx = getRandomMove();
  makeMove(idx, aiSym);
}

/* Random available move */
function getRandomMove(){
  const avail = board.map((v,i)=>v===null?i:null).filter(v=>v!==null);
  if(avail.length===0) return null;
  return avail[Math.floor(Math.random()*avail.length)];
}

/* Medium move: try to win, else block, else center, else random */
function getMediumMove(){
  // try win
  for(let i=0;i<9;i++){
    if(board[i]===null){
      const copy = board.slice(); copy[i]=aiSym;
      if(checkWinner(copy)?.winner === aiSym) return i;
    }
  }
  // try block player
  for(let i=0;i<9;i++){
    if(board[i]===null){
      const copy = board.slice(); copy[i]=playerSym;
      if(checkWinner(copy)?.winner === playerSym) return i;
    }
  }
  // center
  if(board[4]===null) return 4;
  // opposite corner tactic (simple)
  const corners = [0,2,6,8].filter(i=>board[i]===null);
  if(corners.length) return corners[Math.floor(Math.random()*corners.length)];
  return getRandomMove();
}

/* Simple hint: use medium logic */
function getBestMoveSimple(){
  if(difficulty === 'easy') return getRandomMove();
  if(difficulty === 'medium') return getMediumMove();
  return getBestMoveMinimax(board.slice(), aiSym).idx;
}

/* Minimax algorithm for 'hard' difficulty */
function getBestMoveMinimax(newBoard, maximizingSymbol){
  // returns {idx,score}
  const avail = newBoard.map((v,i)=>v===null?i:null).filter(v=>v!==null);
  const winnerCheck = checkWinner(newBoard);
  if(winnerCheck){
    if(winnerCheck.winner === aiSym) return {score: 10};
    if(winnerCheck.winner === playerSym) return {score: -10};
    if(winnerCheck.winner === null) return {score: 0};
  }

  const isMaximizing = (maximizingSymbol === aiSym);
  let bestMove = {idx:null, score: isMaximizing ? -Infinity : Infinity};

  for(const i of avail){
    newBoard[i] = isMaximizing ? aiSym : playerSym;
    const result = getBestMoveMinimax(newBoard, isMaximizing ? playerSym : aiSym);
    newBoard[i] = null;
    const score = result.score;
    if(isMaximizing){
      if(score > bestMove.score){
        bestMove = {idx:i, score};
      }
    } else {
      if(score < bestMove.score){
        bestMove = {idx:i, score};
      }
    }
  }
  return bestMove;
}

/* Winner check function: returns {winner, line} or null for not finished */
function checkWinner(bd){
  const lines = [
    [0,1,2],[3,4,5],[6,7,8],
    [0,3,6],[1,4,7],[2,5,8],
    [0,4,8],[2,4,6]
  ];
  for(const L of lines){
    const [a,b,c] = L;
    if(bd[a] && bd[a] === bd[b] && bd[a] === bd[c]){
      return {winner: bd[a], line: L};
    }
  }
  // tie?
  if(bd.every(c=>c!==null)){
    return {winner: null, line: null};
  }
  return null;
}

/* Announce win */
function announceWin(info){
  const winner = info.winner;
  // disable clicks
  running = false;
  // visually disable remaining cells
  cells.forEach(c=>c.classList.add('disabled'));
  // highlight winning line
  showWinningLine(info.line);
  if(winner === playerSym){
    statusText.textContent = 'Você venceu! 🎉';
    scores.player++;
    // confetti
    launchConfetti();
  } else {
    statusText.textContent = 'Máquina venceu.';
    scores.ai++;
  }
  subStatus.textContent = `Resultado: ${winner}`;
  updateScoreLabel();
}

/* Announce tie */
function announceTie(){
  running = false;
  statusText.textContent = 'Empate!';
  subStatus.textContent = 'Ninguém venceu.';
  scores.ties++;
  updateScoreLabel();
}

/* Update labels */
function updateStatus(){
  turnLabel.textContent = running ? `Vez: ${currentTurn}` : 'Jogo parado';
  statusText.textContent = running ? `Jogue seu turno (${playerSym})` : statusText.textContent;
  subStatus.textContent = running ? `Dificuldade: ${capitalize(difficulty)}` : subStatus.textContent;
  updateScoreLabel();
}
function updateScoreLabel(){
  scoreLabel.textContent = `Você ${scores.player} • Máquina ${scores.ai} • Empates ${scores.ties}`;
}
function capitalize(s){ return s.charAt(0).toUpperCase() + s.slice(1); }

/* Show a line across the winning 3 */
function showWinningLine(line){
  if(!line) return;
  // compute positions of the three cells
  const first = cells[line[0]].getBoundingClientRect();
  const last = cells[line[2]].getBoundingClientRect();
  const parent = boardEl.getBoundingClientRect();
  // center positions relative to board
  const x1 = first.left + first.width/2 - parent.left;
  const y1 = first.top + first.height/2 - parent.top;
  const x2 = last.left + last.width/2 - parent.left;
  const y2 = last.top + last.height/2 - parent.top;
  const lx = Math.hypot(x2-x1, y2-y1);
  const angle = Math.atan2(y2-y1, x2-x1) * 180/Math.PI;
  lineEl.style.width = Math.max(lx, 40) + 'px';
  lineEl.style.left = ( (x1 + x2)/2 - lx/2 ) + 'px';
  lineEl.style.top = ( (y1 + y2)/2 - 3 ) + 'px';
  lineEl.style.transform = `rotate(${angle}deg)`;
  lineEl.style.opacity = 1;
}

/* Confetti (simple) */
function launchConfetti(){
  const colors = ['#f97316','#fb7185','#60a5fa','#34d399','#facc15','#a78bfa'];
  const num = 90;
  for(let i=0;i<num;i++){
    const el = document.createElement('div');
    el.className = 'confetti-piece';
    const w = 8 + Math.random()*12;
    const h = 10 + Math.random()*18;
    el.style.width = w+'px';
    el.style.height = h+'px';
    el.style.left = Math.random()*100 + 'vw';
    el.style.top = ( -5 - Math.random()*10) + 'vh';
    el.style.background = colors[Math.floor(Math.random()*colors.length)];
    el.style.transform = `rotate(${Math.random()*360}deg)`;
    el.style.animationDuration = (2 + Math.random()*2.2) + 's';
    el.style.opacity = 0.95;
    document.body.appendChild(el);
    // remove after animation
    setTimeout(()=>el.remove(), 4000 + Math.random()*1000);
  }
}

/* Utility: return best move (minimax wrapper) */
function getBestMoveMinimax(boardState, forPlayer){
  // wrapper that runs minimax with alpha-beta? (simple version)
  // Here we will implement a depth-limited minimax returning idx+score.
  // We'll use the algorithm similar to the recursive function above, but improved to return idx when top-level.
  const winnerInfo = checkWinner(boardState);
  if(winnerInfo) {
    if(winnerInfo.winner === aiSym) return {idx:null, score:10};
    if(winnerInfo.winner === playerSym) return {idx:null, score:-10};
    if(winnerInfo.winner === null) return {idx:null, score:0};
  }

  const available = boardState.map((v,i)=>v===null?i:null).filter(v=>v!==null);
  // if only one move left
  if(available.length === 1) return {idx: available[0], score:0};

  // recursion
  function recurse(bd, maximizing){
    const check = checkWinner(bd);
    if(check){
      if(check.winner === aiSym) return {score:10};
      if(check.winner === playerSym) return {score:-10};
      return {score:0};
    }
    const moves = bd.map((v,i)=>v===null?i:null).filter(v=>v!==null);
    let best = maximizing ? {score:-Infinity} : {score:Infinity};
    for(const m of moves){
      bd[m] = maximizing ? aiSym : playerSym;
      const res = recurse(bd, !maximizing);
      bd[m] = null;
      const sc = res.score;
      if(maximizing){
        if(sc > best.score){ best = {idx:m, score:sc}; }
      } else {
        if(sc < best.score){ best = {idx:m, score:sc}; }
      }
    }
    return best;
  }
  const top = recurse(boardState.slice(), true);
  return top;
}

/* ----- small UX polish: animate the start button pulse ----- */
(function pulseStart(){
  startBtn.animate([{transform:'translateY(0)'},{transform:'translateY(-4px)'}],{duration:1200,iterations:Infinity,direction:'alternate'});
})();

/* allow clicking Enter to start */
document.addEventListener('keydown', (e)=>{
  if(e.key === 'Enter') startBtn.click();
});

/* safety: if user navigates away, pause audio */
document.addEventListener('visibilitychange', ()=>{
  if(document.hidden) try{ bgAudio.pause(); } catch(e){}
});

/* PREVENT: undo not implemented — just placeholder */
// (optionally could implement move stack)

/* Quick initial call to set labels */
updateStatus();

</script>
</body>
</html>
